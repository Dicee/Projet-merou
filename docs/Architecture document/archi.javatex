 packages ##
fontenc[T1]
color
amssymb
amsmath
eurosym
graphicx
textcomp
listings
epigraph
setspace
background[some]
gensymb
tikz
geometry
fancyhdr
babel[english]
##
 commands ##
scala.listing
dark-scala.listing
##
 documentSettings ##
documentClass=report
alinea=4mm
chapterName=Chapter
##
 preprocessor ##
\pagestyle{fancy}
##
> title[titlePage.projet-merouTemplate] ##
date=February $12^{th}$ 2015
ref=model-checking.archi
first_author_name=Zohour \textsc{Abouakil} ~\\ Sofia \textsc{Boutahar} ~\\ David \textsc{Courtinot} ~\\ Xiaowen \textsc{Ji} ~\\ Fabien \textsc{Sauce}
title_size=0.7
sup_strip_color=0.70,0.70,0.70
inf_strip_color=0.00,0.00,0.00
title=Architecture document
version=1
##
> chapter ##
Context
##
>> section ##
Objectives and motivations
##
>>> paragraph ##
As everyone knows, embedded systems are most often critical systems and must be as robust as possible to avoid critical failures which could have dramatic consequences.
Hence, many researches are done in order to build tools that would help to ensure the good properties of an embedded system source code and compensate potential human
failure. The model checking, which consists in asserting properties on a model thanks to graph search algorithms (for example), is one of those fields that can be
applied to this matter. In this project, we are trying to build a model checker working on C++ code which takes the source code as an input and is transformed a few times
in various abstract representations to end with a graph model that we are able to send to a model checker.
##
>> section ##
Definitions
##
>>> subsection ##
AST - Abstract Syntax Tree
##
>>>> paragraph ##
The AST is an abstract (and low-level) representation of the code. It is a tree data-structure which describes the code in a purely syntactic point of view. As an example,
you can see below a simple C/C++ code and its AST representation. The AST is provided by the Clang API, which performs the first step of our
transformation chain.
##
>>>> code ##
java
void fun(int &a) {
    ++a;
}

int main(int argc, char* argv[]) {
    int num = 10;
    if (num > 5)
        fun(num);
    
    return 0;
}
##
>>>> image ##
data/ast.png;
The AST corresponding to the above code;
0.5
##
>>> subsection ##
CFG - Control Flow Graph
##
>>>> paragraph ##
The CFG is a graph representing all the possible execution paths (with some restrictions, for example
we won't create several nodes for a single expression even if in reality an expression should be a graph).
As an example, you can find below the CFG generated by a  do while statement in an if statement.
##
>>>> image ##
data/doWhile.png;
An example of CFG;
0.45
##
>>> subsection ##
CTL - Computation Tree Logic
##
>>>> paragraph ##
CTL is a way of representing temporal logic expressions on a graph or a tree. For example, it can
express properties such as \textit{<< All the paths starting from every node verifies the predicate p >>}.
##
> chapter ##
AST and CFG representations
##
>> paragraph ##
After studying the Clang API, we came to the conclusion that the AST is a much more low-level representation of the program than the CFG. 
Indeed, the atom for a CFG is what is generally called a \textit{statement} whereas the simplest instruction
gives an AST representation composed of multiple nodes. We also found it difficult to handle the parsing and the linking of the graph nodes at the same time.
Thus, we have chosen to transform the AST into a series of higher-level objects than the original nodes, which will be converted
in nodes of the CFG.
##
>> image ##
data/transform_chain.png;
Transformation chain we are going to present;
0.5
##
>> section ##
Intermediate representation of the Clang AST
##
>>> subsection ##
Parsing the Clang AST file
##
>>>> paragraph ##
At first, we have considered using XML parsing libraries to parse the XML version of the Clang AST. However, 
this type of output is no longer supported by the newest versions of the Clang compiler and all the existing tools
provide partial support at best. Hence, we decided using the regular AST file and parse it line by line 
with a custom parser.
##
>>>> paragraph ##
We have identified three main kinds of nodes in the AST. Each one is associated to a specific class which extends ASTNode :
##
>>>> list ##
nodes consisting in an type name, an id, a code pointer pointing the relevant lines of the code and some
metadata that depend on the type of the node. These are represented by the ConcreteASTNode class.;
< < <NULL> > > children, represented by the NullASTNode class.;
other kind of nodes, prior to class declaration for example. These are represented by OtherASTNode.
##
>>>> paragraph ##
The file will be parsed and converted in a tree data-structure which nodes are of type ASTNode. The ASTNode objects
will then be converted in Stmt or Decl accordingly to the class hierarchy we present in the next part.
##
>>>> image ##
data/AST_classes.png;
Class hierarchy for the output format of the ASTParser;
0.5
##
>>> subsection ##
From ASTNode to SourceCodeNode
##
>>>> paragraph ##
The SourceCodeNode class represents a tree data-structure which is still close enough to the AST 
but with a higher abstraction, and some removed low-level information.
##
>>>> subsubsection ##
Decl class hierarchy
##
>>>>> paragraph ##
For the Decl part,  which represents the different kinds of declarations in the code, we did not have too much trouble and just had to associate each high-level Clang Decl class to a Scala class extending
our Decl class, as it is shown in the previous figure.
##
>>>> subsubsection ##
Stmt part
##
>>>>> paragraph ##
Stmt is a Clang asbtraction of a statement in a program (any expression, any flow-control structure). As it was not presented as a priority by the client, we have decided to skip the C++ object oriented 
part in order to focus exclusively on the imperative part. Inspired by the Clang API, we came up
 with the following class diagram :
##
>>>>> image ##
data/basic_Stmt_classes.png;
Representation of the most classes statements;
0.5

##
>>>>> image ##
data/flow_control_Stmt_classes.png;
Flow-control structures;
0.5
##
>>>>> image ##
data/Expr_classes.png;
Detail of the Expr class hierarchy;
0.5
##
>>>>> paragraph ##
Note that our model does not strictly represents a C++ code. For example, we do not prevent a \textit{if} to contain the instruction \textit{break}
(among other inaccuracies ...). We felt that this kind of refinement would unnecessarily complicate the task without adding anything more to the CFG analysis. 
Since the code is already semantically checked by the Clang compiler and given our future needs, we thought it would be wiser to aim for a simple model.
##
>>>> subsubsection ##
Important notes
##
>>>>> list ##
To accurately represent the CFG of our input programs, we should take into account the fail-fast mechanism in the evaluation of boolean conjunctions/disjunctions.
The importance of this mechanism for our project is illustrated in the figure below.;
However, since the evaluation's order of the expressions is not completely specified specified in C++ (unlike Java which evaluates from left to right),
we will ignore that even if it will surely change the result for certain kind of treatments when some expressions contain side-effect sub-expressions
 (increment, assignments...).
##
>>>>> image ##
data/fail-fast.png;
On the left the considerate code. On the center, we didn't take into account the fail-fast for the CFG, and finally on the right we consider the fail-fast;
0.85
##
>>>>> paragraph ##
Just to see what we are losing by ignoring that kind of things is illustrated in the figure above : if we try to
assert the property \textit {<< variable s is always initialized when g(s) is called >>}, the first CFG will not allow us to conclude
(or it will conclude \textbf {true}, erroneously) while the second allows us
to state that there are executions, according to the value of x,
where $g$ is called with an uninitialized parameter
(assuming that the left son is always a successful test and the right son is a failed test). It is not really a problem, as
we could argue that it is fine to use fail-fast most of the times but that it is safer not to use it for a critical program.
##
>>>>> paragraph ##
Another important thing to mention is that at the beginning, we had a mix of regular classes with
var/val members and case classes. Moreover, we were using <<var>> immutable lists (class List) for building
incrementally some collections as the list of statements in a compound statement. However, it would imply to append at the end
because otherwise, the list would have been to be reversed each time needed. Therefore, we have created a simple wrapper of ArrayBuffer,
that hides all the ArrayBuffer definitions except $+=$, and otherwise behaves as an immutable List. Same thing was done with
a wrapper of a mutable HashMap (for storing declaration by their name for example). This enables to use 
a more functional programming style while being efficient.
##
>>>>> paragraph ##
Finally, we chose to make all the classes as case-classes to enable the powerful Scala pattern-matching.
Most algorithms are recursive, the parsing of the AST being the only exception.
##
>> section ##
SourceCodeNode to CFG
##
>>> paragraph ##
Considering that Stmt and Decl children classes were partly low-level elements of the code that are not important
in the CFG, we decided to perform a last step of transformation from SourceCodeNode to ProgramNode, which is a simpler and higher level abstraction of the code.
The ProgramNode objects will be the values of the nodes of the actual graph, represented by the class GraphNode[T].
##
>>> paragraph ##
GraphNode is actually a generic type, completely independent of all the classes we introduced so far.
It basically represents any oriented unweighted graph. The conversion from SourceCodeNode to
ProgramNode is handled on the fly while constructing the CFG (GraphNode[ProgramNode]), which
consists in creating the links between the various nodes of the graph.
##
>>> image ##
data/CFG_classes.png;
ProgramNode class hierarchy and GraphNode;
0.5
##
>>> paragraph ##

##
> chapter ##
Model checking
##

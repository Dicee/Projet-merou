 packages ##
fontenc[T1]
color
amssymb
amsmath
eurosym
graphicx
textcomp
listings
epigraph
setspace
background[some]
gensymb
tikz
geometry
fancyhdr
babel[english]
##
 commands ##
js-html-css.listing
java.listing
##
 documentSettings ##
documentClass=report
alinea=4mm
chapterName=Part
##
 preprocessor ##

##
> title[titlePage.projet-merouTemplate] ##
date=February 16th, 2015
ref=model-checking.test-strategy
first_author_name=Sofia \textsc{Boutahar} ~\\
title_size=0.9
sup_strip_color=0.70,0.70,0.70
inf_strip_color=0.00,0.00,0.00
title=Test strategy
version=1
##
>> chapter ##
Overview
##
>>> paragraph ##
The purpose of a test strategy is to clarify the major tasks and challenges of the test project, define what we want to accomplish and how we are going to achieve it. Moreover, it helps us figure out if there are missing requirements in the project and have a clear state of it at any point.
Our project is divided into two parts: The conversion of the AST to the CFG and the model checking using CTL.
The first part can be divided into two subparts : Parsing the file generated by the Clang compiler and converting the AST to the CFG.
##
>> chapter ##
Testing AST conversion to CFG
##
>>> section ##

##
>>> section ##
Test strategy
##
>>>> paragraph ##
When we identify a particular problem in our code, we try to debug it and the fix the issues. 
To make sure that the fix works, we test our program again to see if it works. Therefore, it is not sufficient to validate the test if the tested program works, we should make sure that our fixes don't create some other problems in any other parts of our projects due to dependencies.
So, a set of related test cases may have to be repeated again, to make sure that nothing else is affected our fixes.
Basically, whenever there is a fix in one unit, we repeat all unit test cases for that unit in order to achieve a higher level of abstraction and quality.
##
>>> section ##
Testing the parser

##
>>>> paragraph ##
The clang compiler takes a C++ source code as input 
and returns a file describing an Abstract Syntax Tree. The purpose of creating a parser
is to extract from the Clang file all the useful information and build a tree
that contains it. 

As the number of possible tests for our parser is practically infinite, we created several tests
starting from the easiest to the most complicated one. The aim was to ensure that our
program is working for the minimum number of tests needed to get the coverage we want.



##
>>> section ##
Testing results
##
>>>> paragraph ##
We  
##

 packages ##
fontenc[T1]
color
amssymb
pdfpages
amsmath
eurosym
graphicx
textcomp
listings
epigraph
longtable
setspace
array
gensymb
tikz
background[some]
fancyhdr
geometry[margin=0.9in]
babel[english]
enumerate
##
 commands ##
##
 documentSettings ##
documentClass=report
alinea=4mm
chapterName=Part
##
 preprocessor ##
\pagestyle{fancy}
##
> title[titlePage.projet-merouTemplate] ##
date=February $13^{th}$ 2015
title_size=0.7
sup_strip_color=0.70,0.70,0.70
description=\textbf{Reference} : model-checking.dev-plan ~\\
title=Development plan
version=3
ref=model-checking.dev-plan
vertical_strip_color=1.00,0.50,0.50
first_author_info=Fabien \textsc{Sauce}
first_author_name=Zohour \textsc{Abouakil} ~\\ Sofia \textsc{Boutahar} ~\\ David \textsc{Courtinot} ~\\ Xiaowen \textsc{Ji} ~\\ Fabien \textsc{Sauce}
horizontal_strip_color=0.70,0.10,0.10
inf_strip_color=0.00,0.00,0.00
description_size=1.2
##
> latex ##
\chapter*{Changelog}
\begin{center}
\begin{tabular}{|c|l|l|}
  \hline
  Version & Date & Change  \\
  \hline
  V2 & January $26^{th}$  & translated everything from french to english \\
   & January $26^{th}$  & minor fixes in the risk management \\
   & January $26^{th}$  & added information on the different roles \\
   & January $26^{th}$  & added a part on the quality checking \\
   & January $26^{th}$  & updated the planning \\
   & February $06^{th}$ & filled up deliverable section \\
  \hline
  V3 & February $10^{th}$ & gave more details about the program functionalities \\
  & February $13^{th}$ & added a header, improved the changelog presentation \\
  \hline
\end{tabular}
\end{center}
##
> chapter ##
Project description and objectives
##
>> section ##
Surroundings of the project
##
>>> subsection ##
What is "Projet long" ?
##
>>>> paragraph ##
To get our ENSEEIHT engineering diploma, we are required to take part in 
a project called "Projet long" in teams of five students to work 
on a common project.
##
>>>> paragraph ##
The project started on January 19, and will last eight weeks. It ends up with 
a defense in which we promote our work in front of a jury which evaluates 
us against different aspects :
##
>>>> list ##
Project management and organization ; 
        Technical accomplishment ;
        Report and defense presentation ; 
        English evaluation
##
>>>> paragraph ##
All over the project, we have to work side by side with the client
 for whom we have to deliver, at the end of the project,
 a product that suits their expectations. Furthermore, we are 
also supervised by Mr. Jean-Francois COIFFIN. He is in charge 
of helping us through his experience in the project management and 
organization.
##
>>> subsection ##
Who are our clients ?
##
>>>> paragraph ##
The subject that we work on was made by Mr. David Doose and
 Mr. Julien Brunel, two researchers at Aerospace Lab ONERA. They are
 working on robot development using C++ language. This is why they are
 in the need of a model checking tool to assert some properties on their 
embedded system's code. The client already has a similar product, called Coccinelle. 
However, Coccinelle is limited to looking for patterns in C code.
##
>>> subsection ##
What made us choose this subject ?
##
>>>> paragraph ##
We chose to work on that project because of the originality of the subject, since it is mixing theoretic computer science and technical advanced principles.
       Moreover, studying model checking and temporal logic to assert properties on a source code was a topic that we studied in ENSEEIHT courses. This project is an opportunity to apply this theory and dive deeper into it.
##
>> section ##
Project description
##
>>> subsection ##
Main idea
##
>>>> paragraph ##
The client is waiting for a prototype that allows a search of patterns on a C++ code. The patterns will be expressed in terms of temporal logic properties.
##
>>> subsection ##
Project parts
##
>>>> paragraph ##
The project can be divided into two main parts :
##
>>>> list ##
\textbf{Parser :} takes a C++ code file as an input and transforms it into a data structure -a graph called CFG, as in Control Flow Graph- to explore every possible execution trace;
            \textbf{Model checking algorithm :} this algorithm takes a property to check and tries to find the nodes in the graph that verify it.
##
>>>> paragraph ##
After realizing both parts separately, we have to make it work togetger : this is the final product.
The following graph shows the main steps in our project.
##
>>>> image ##
data/tasks;
            Project parts;
            0.7
##
>>>> paragraph ##
The tasks colored in orange represent possible (and optional) extensions of the product.
##
>>> subsection ##
Related technologies
##
>>>> paragraph ##
To simplify the C++ code parsing we will use an intermediate tool : Clang. It is a compiler front-end for C, C++, Objective-C and Objective-C++ and developed by Apple. It takes a C++ file as input and outputs a file describing an AST (Abstract Syntax Tree).
##
>> section ##
Functionalities
##
>>> paragraph ##
Features expected by the customer :
##
>>> latex ##
\begin{enumerate}
        \item Implementation of a parser for the AST generated by Clang
        \item Conversion from AST to a Scala model representation of the code in terms of graph control flux
        \item Independently of the two preceding items, algorithms for the analysis of CTL properties (Computation Tree Logic) on some control flow graphs;
        \item Adding to CTL some quantifiers such as "exists". This is known as CTL-V (CTL with quantified variables).
    \end{enumerate}
##
>>> subsection ##
AST parsing
##
>>>> paragraph ##
Our program takes as an input a file of AST format. We have first of all to read and extract useful informations and store them into a Scala structure :
##
>>>>> list ##
variable declaration and assignment;
    function definition and structure;
    position of the matches in the source code;
    type information;
    object oriented functionalities of C++
##
>>>> paragraph ##
Optionally, we will also provide the following features  :
##
>>>>> list ##
unfold function calls on a certain depth, otherwise a function call is only considered as an expression
##
>>> subsection ##
Get a graph representation form an AST structure
##
>>>> paragraph ##
The result of AST parsing is a raw data that have to be structured and used for checking some code properties. This is why we transform our basic structure into a graph structure traversable by a model checker algorithm.
##
>>> subsection ##
Check CTL properties on a CFG
##
>>>> paragraph ##
Getting any CFG as an input our program have to check some CTL properties on it. This is why we use a model checker algorithm. It is the intelligent part of the program since it has to find out the CFG nodes that respect a CTL property.
##
>>> subsection ##
Optional functionalities
##
>>>> list ##
add a new language to define CTL properties
##
>> section ##
Deliverable documents and define priorities
##
>>> paragraph ##
Deliverables expected by the client are:
##
>>> list ##
Specification documents;
Documented source code in Scala language;
Test strategy and test results; 
Architecture document;
User guide
##
>>> paragraph ##
Deliverables expected by the supervisor and ENSEEIHT are:
##
>>> list ##
Specification documents;
Report in PDF format;
Development plan in PDF format;
Presentation supports
##
> chapter ##
Project organization
##
>> section ##
Roles definition
##
>>> subsubsection ##
Project manager
##
>>>> paragraph ##
The project manager is primarily concerned about communications with the industrial and the customers. It has a leading role in the organization and planning of the tasks.
##
>>> subsubsection ##
Supervisor
##
>>>> paragraph ##
The supervisor has a global technical view of the project. He supervises the advancement of simultaneous tasks. Otherwise, he can rearrange groups and objectives if an unforeseen occurs. The supervisor has also to participate in coding or documenting an assigned task. Nevertheless, it is not his primary function.
##
>>>> paragraph ##
The team supervisor can change from one week to another.
##
>>> subsubsection ##
Quality manager
##
>>>> paragraph ##
The quality manager is in charge of checking that every deliverable documents meets the quality standards. In other words, any produced code will pass under the watchful eye of the quality manager before being validated. He also ensures the quality and consistency of all documents produced by the team.
##
>>> subsubsection ##
Test manager
##
>>>> paragraph ##
The test manager is responsible of the validation and testing in global environment written by the developers (each developer has its own set of unit tests). He does not only run tests, he also determines whether the tests are complete or not (code coverage).
##
>>> subsubsection ##
Configuration manager
##
>>>> paragraph ##
The configuration manager should take care of every tool we are going to use, make some choice about which tools are better than other (example :
Scalastyle, an Eclipse plugin that we use for automated quality checks).
In particular he will handle the installation and the follow up of a version tool as Github for example.
##
>>> subsubsection ##
Development chain
##
>>>> image ##
data/cycle_qualite;
            Scheme describing our development chain;
            0.7
##
>> section ##
Development organisation
##
>>> paragraph ##
To secure our evolution we will use some methods inspired of famous project management techniques.
##
>>> subsection ##
The Scrum method
##
>>>> paragraph ##
We will try to use the Scrum method, which is widely used, and recognized for its effectiveness. At first, we will define a \textit{product backlog} containing all desired functionalities in the final product. In fact, this report is also a part of the \textit{product backlog}. 
Next, we will divide the project into three \textit{sprints} (which means iterations). A \textit{sprint backlog} is defined for each \textit{sprint}, including all we need to realise at the end of an iteration. Each \textit{sprint} lasts two weeks and lies in improve the software 
incrementally, so that it is close to \textit{product backlog}.
##
>>>> paragraph ##
At the end of each \textit{sprint}, we will organise a meeting, in order to review the progress and propose improvements or modifications of planning,
 but in the process of a \textit{sprint}, we cannot modify the \textit{sprint backlog}. 
To finish, each day starts with a \textit{scrum meeting}, on the meeting, each 
team member present his objective of the day and his actual difficulties.
##
>>> subsection ##
Team repartition approach
##
>>>> paragraph ##
We will use an approach inspired by the XP (extreme programming) method. 
Considering the amount of code that we will have to write, we find it unnecessary that the five team members work separately, 
and we consider as excellent to work in pairs, in order to prevent errors and bias 
of the program structure, so that we can save times in testing and debugging. 
As a consequence, four of us will work in pairs and the last one works individually. The groups repartition
may change as the tasks are completed.
##
>> section ##
Tasks organisation
##
>>> subsection ##
Tasks definition
##
>>>> paragraph ##
Sprint 1 backlog:
##
>>>> list ##
AST parsing of procedure C++ code;
CFG conversion from parsed AST;
Model checking with simple properties;
##
>>>> paragraph ##
Sprint 2 backlog:
##
>>>> list ##
AST parsing of object oriented C++ code;
CFG conversion from parsed AST;
Model checking with simple criteria;
##
>>>> paragraph ##
Sprint 3 backlog:
##
>>>> list ##
Improved CFG conversion from parsed AST;
Model checking with complex criteria;
##
>>> subsection ##
Planning
##
>>>> latex ##
\includepdf[landscape=true,pages={1}]{data/planning.pdf}
##
> chapter ##
Risk management
##
>> image ##
data/risks.png;
Analyse des risques;
0.5
##
> chapter ##
Code and documentation management
##
>> section ##
Quality management
##
>>> subsection ##
Automated coding style checks
##
>>>> paragraph ##
For ensuring that our coding rules are respected and evaluate the quality of our sources, we have
used a tool called \textit{Scalastyle} that enables, using an easy-to-use xml configuration file, to check
some properties on a Scala code. Combined with a specific pulgin, this can be used to generate warnings or errors
in the IDE the developer is using. Our settings are the following :
##
>>>> latex ##
\renewcommand{\arraystretch}{1.2}
\begin{center}
\begin{longtable}{|l|l|l|}
\hline
\textbf{Rule} & \textbf{Description} & \textbf{Value}  \\
\hline
FileLengthChecker & \small{Check the number of lines in a file} & 1500  \\
\hline
FileLineLengthChecker & \small{Check the number of characters in a line} & 140 \\
\hline
FileTabChecker & \small{Check that there are no tabs in a file} & enabled \\
\hline
ClassNamesChecker & \small{Check that class names match a regular}  & \^ [A-Z][A-a-z]*\$ \\
& \small{expression} & \\
\hline
\small{ClassTypeParameterChecker} & \small{Checks that type parameter to a class matches a} & \^[A-Z\_]\$ \\
& regular expression & \\
\hline
FileTabChecker & \small{Check that there are no tabs in a file} & enabled \\
\hline
\small{CyclomaticComplexityChecker} & \small{Checks that the cyclomatic complexity of a method} & 12 \\
&  \small{does exceed a value} & \\
\hline
EmptyClassChecker & \small{If a class/trait has no members, the braces are} & enabled \\
&  \small{unnecessary} & \\
\hline
\small{EqualsHashCodeChecker} & \small{Check that if a class implements either equals} & enabled \\ 
 & \small{or hashCode, it should implement the other} & \\
\hline
MethodLengthChecker & \small{Checks that methods do not exceed a maximum} & 50 \\
& \small{length} & \\
\hline
MethodNamesChecker & \small{Check that method names match a regular} & \^[a-z][A-Za-z0-9]*(\_=)?\$ \\
\tiny{.} & \small{expression} & \\
\hline
\small{MultipleStringLiteralsChecker} & \small{Checks that a string literal does not appear} & allowed = 2 \\
& \small{multiple times} & \\
\hline
\small{NotImplementedErrorUsage} & \small{Checks that the code does not have ??? operators} & enabled \\
\hline
NullChecker & \small{Check that null is not used} & enabled \\
\hline
\small{NumberOfMethodsInTypeChecker} & \small{Check that a class/trait/object does not have too} & maxMethods = 30 \\
& \small{many methods} & \\
\hline
NumberOfTypesChecker & \small{Checks that there are not too many types} & maxTypes = 20 \\
& \small{declared in a file} & \\
\hline
ObjectNamesChecker & \small{Check that object names match a regular}  & \^[A-Z][A-Za-z]*\$ \\
& \small{expression} & \\
\hline
ParameterNumberChecker & \small{Maximum number of parameters for a method} & maxParameters = 5 \\
\hline
RedundantIfChecker & \small{Checks that if expressions are not redundant, ie} & enabled \\
& \small{easily replaced by a variant of the condition} &  \\
\hline
ScalaDocChecker & \small{Checks that the ScalaDoc on documentable}  & enabled \\
& \small{members is well-formed} & \\
\hline
\end{longtable} 
\end{center}
% \restoregeometry
\renewcommand{\arraystretch}{1}
##
>>> subsection ##
Verification by pair
##
>>>> paragraph ##
As we have opted for an XP model for the programming aspect of the project,
we consider that a code has passed the quality test if at least the two members of a pair
have checked it. This is up to the quality manager to ensure this has been done, otherwise he
should do it himself.
##
>>>> paragraph ##
This is specific to the code quality checks and does not apply to the rest of the delivrable documents.
##
>> section ##
Configuration management
##
>>> paragraph ##
All the delivrable documents are managed on a git repository, including documentation and reports.
Anyone is allowed to commit at anytime, however any push must have been authorized by the quality responsible after the code
has been thoroughly tested against a set of tests by the test responsible.
##
